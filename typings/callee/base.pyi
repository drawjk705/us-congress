"""
This type stub file was generated by pyright.
"""

from callee._compat import metaclass

"""
Base classes for argument matchers.
"""
class BaseMatcherMetaclass(type):
    """Metaclass for :class:`BaseMatcher`."""
    USER_OVERRIDABLE_MAGIC_METHODS = ...
    def __new__(meta, classname, bases, dict_):
        """Create a new matcher class."""
        ...
    


@metaclass(BaseMatcherMetaclass)
class BaseMatcher(object):
    """Base class for all argument matchers.

    This class shouldn't be used directly by the clients.
    To create custom matchers, inherit from :class:`Matcher` instead.
    """
    __slots__ = ...
    def match(self, value):
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __invert__(self):
        ...
    
    def __and__(self, other):
        ...
    
    def __or__(self, other):
        ...
    
    def __xor__(self, other):
        ...
    


class Matcher(BaseMatcher):
    """Base class for custom (user-defined) argument matchers.

    To create a custom matcher, simply inherit from this class
    and implement the :meth:`match` method.

    If the matcher is more complicated (e.g. parametrized),
    you may also  want to provide a :meth:`__repr__` method implementation
    for better error messages.
    """
    def __repr__(self):
        """Provides a default ``repr``\ esentation for custom matchers.

        This representation will include matcher class name
        and the values of its public attributes.
        If that's insufficient, consider overriding this method.
        """
        ...
    


class Eq(BaseMatcher):
    """Matches a value exactly using the equality (``==``) operator.

    This is already the default mode of operation for ``assert_called_with``
    methods on mocks, making this matcher redundant in most situations::

        mock_foo.assert_called_with(bar)
        mock_foo.assert_called_with(Eq(bar))  # equivalent

    In very rare and specialized cases, however, if the **tested code** treats
    `callee` matcher objects in some special way, using :class:`Eq` may be
    necessary.

    Those situations shouldn't generally arise outside of writing tests
    for code that is itself a test library or helper.
    """
    def __init__(self, value) -> None:
        """:param value: Value to match against"""
        ...
    
    def match(self, value):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    


class Is(BaseMatcher):
    """Matches a value using the identity (``is``) operator."""
    def __init__(self, value) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    


class IsNot(BaseMatcher):
    """Matches a value using the negated identity (``is not``) operator."""
    def __init__(self, value) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    


class Not(BaseMatcher):
    """Negates given matcher.

    :param matcher: Matcher object to negate the semantics of
    """
    def __init__(self, matcher) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __repr__(self):
        ...
    
    def __invert__(self):
        ...
    
    def __and__(self, other):
        ...
    
    def __or__(self, other):
        ...
    


class And(BaseMatcher):
    """Matches the argument only if all given matchers do."""
    def __init__(self, *matchers) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __repr__(self):
        ...
    


class Or(BaseMatcher):
    """Matches the argument only if at least one given matcher does."""
    def __init__(self, *matchers) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __repr__(self):
        ...
    


class Either(BaseMatcher):
    """Matches the argument only if some (but not all) of given matchers do.

    .. versionadded:: 0.3
    """
    def __init__(self, *matchers) -> None:
        ...
    
    def match(self, value):
        ...
    
    def __repr__(self):
        ...
    


OneOf = Either
Xor = Either
